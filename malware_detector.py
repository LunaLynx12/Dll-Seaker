"""
Malware Detection Heuristics - Detect suspicious patterns in DLLs
"""

import math
from typing import Dict, List, Any, Optional
from collections import Counter


class MalwareDetector:
    """Detect suspicious patterns and malware indicators"""
    
    # Suspicious import combinations
    SUSPICIOUS_IMPORTS = {
        'memory_manipulation': [
            'VirtualAlloc', 'VirtualProtect', 'WriteProcessMemory',
            'ReadProcessMemory', 'NtAllocateVirtualMemory'
        ],
        'process_injection': [
            'CreateRemoteThread', 'NtCreateThreadEx', 'QueueUserAPC',
            'SetThreadContext', 'WriteProcessMemory'
        ],
        'anti_debugging': [
            'IsDebuggerPresent', 'CheckRemoteDebuggerPresent',
            'NtQueryInformationProcess', 'NtSetInformationThread',
            'OutputDebugString', 'CloseHandle'
        ],
        'network_activity': [
            'InternetOpen', 'InternetConnect', 'HttpOpenRequest',
            'WinHttpConnect', 'socket', 'connect'
        ],
        'file_operations': [
            'CreateFile', 'WriteFile', 'DeleteFile', 'MoveFile',
            'CopyFile', 'FindFirstFile', 'FindNextFile'
        ],
        'registry_manipulation': [
            'RegCreateKey', 'RegSetValue', 'RegDeleteKey',
            'RegOpenKey', 'RegQueryValue'
        ],
        'service_manipulation': [
            'CreateService', 'StartService', 'ControlService',
            'OpenSCManager', 'ChangeServiceConfig'
        ],
        'crypto_functions': [
            'CryptEncrypt', 'CryptDecrypt', 'CryptHashData',
            'CryptCreateHash', 'CryptAcquireContext'
        ],
    }
    
    # Suspicious section names
    SUSPICIOUS_SECTIONS = [
        '.packed', '.upx', '.aspack', '.pecompact', '.fsg',
        '.petite', '.nspack', '.wwpack', '.mew', '.upack'
    ]
    
    def __init__(self):
        """Initialize malware detector"""
        self.risk_score = 0
        self.indicators = []
        self.details = {}
    
    def analyze(self, dll_data: Dict[str, Any]) -> Dict[str, Any]:
        """Perform comprehensive malware analysis"""
        self.risk_score = 0
        self.indicators = []
        self.details = {}
        
        # Analyze different aspects
        self._analyze_entropy(dll_data)
        self._analyze_imports(dll_data)
        self._analyze_sections(dll_data)
        self._analyze_exports(dll_data)
        self._analyze_strings(dll_data)
        self._analyze_resources(dll_data)
        self._analyze_characteristics(dll_data)
        
        # Calculate final risk score (0-100)
        risk_level = self._calculate_risk_level()
        
        return {
            'risk_score': min(100, self.risk_score),
            'risk_level': risk_level,
            'indicators': self.indicators,
            'details': self.details,
            'is_suspicious': self.risk_score >= 30,
            'is_high_risk': self.risk_score >= 60
        }
    
    def _analyze_entropy(self, dll_data: Dict[str, Any]):
        """Analyze section entropy"""
        sections = dll_data.get('sections', {}).get('sections', [])
        high_entropy_sections = []
        
        for section in sections:
            entropy = section.get('entropy', 0)
            if entropy > 7.0:  # High entropy threshold
                high_entropy_sections.append({
                    'name': section.get('name'),
                    'entropy': entropy
                })
                self.risk_score += 5
                self.indicators.append(f"High entropy section: {section.get('name')} ({entropy:.2f})")
        
        if high_entropy_sections:
            self.details['high_entropy_sections'] = high_entropy_sections
    
    def _analyze_imports(self, dll_data: Dict[str, Any]):
        """Analyze imported functions for suspicious patterns"""
        imports = dll_data.get('imports', {}).get('imports', {})
        all_imports = []
        
        for dll_name, dll_data in imports.items():
            for func in dll_data.get('functions', []):
                all_imports.append(func.get('name', '').lower())
        
        # Check for suspicious import combinations
        for category, suspicious_funcs in self.SUSPICIOUS_IMPORTS.items():
            found = [f for f in all_imports if any(sf.lower() in f for sf in suspicious_funcs)]
            if len(found) >= 2:  # Multiple suspicious imports
                self.risk_score += 10
                self.indicators.append(f"Suspicious import combination: {category} ({len(found)} functions)")
                if category not in self.details:
                    self.details[category] = []
                self.details[category].extend(found)
        
        # Check for anti-debugging imports
        anti_debug = [f for f in all_imports if any(ad.lower() in f for ad in self.SUSPICIOUS_IMPORTS['anti_debugging'])]
        if anti_debug:
            self.risk_score += 15
            self.indicators.append(f"Anti-debugging techniques detected ({len(anti_debug)} functions)")
            self.details['anti_debugging'] = anti_debug
        
        # Check for process injection imports
        injection = [f for f in all_imports if any(pi.lower() in f for pi in self.SUSPICIOUS_IMPORTS['process_injection'])]
        if len(injection) >= 2:
            self.risk_score += 20
            self.indicators.append(f"Process injection capabilities detected ({len(injection)} functions)")
            self.details['process_injection'] = injection
    
    def _analyze_sections(self, dll_data: Dict[str, Any]):
        """Analyze section names and characteristics"""
        sections = dll_data.get('sections', {}).get('sections', [])
        
        for section in sections:
            name = section.get('name', '').lower()
            
            # Check for suspicious section names
            if any(susp in name for susp in self.SUSPICIOUS_SECTIONS):
                self.risk_score += 15
                self.indicators.append(f"Suspicious section name: {section.get('name')}")
                if 'suspicious_sections' not in self.details:
                    self.details['suspicious_sections'] = []
                self.details['suspicious_sections'].append(section.get('name'))
            
            # Check for executable data sections
            flags = section.get('characteristics_flags', [])
            if 'IMAGE_SCN_MEM_EXECUTE' in flags and 'IMAGE_SCN_CNT_CODE' not in flags:
                self.risk_score += 10
                self.indicators.append(f"Executable non-code section: {section.get('name')}")
    
    def _analyze_exports(self, dll_data: Dict[str, Any]):
        """Analyze exported functions"""
        exports = dll_data.get('exports', {}).get('exports', [])
        
        # Check for suspicious export names
        suspicious_exports = [
            'install', 'setup', 'update', 'service', 'loader',
            'inject', 'hook', 'patch', 'bypass'
        ]
        
        found_suspicious = []
        for exp in exports:
            name = exp.get('name', '').lower()
            if any(susp in name for susp in suspicious_exports):
                found_suspicious.append(exp.get('name'))
        
        if found_suspicious:
            self.risk_score += 5
            self.indicators.append(f"Suspicious export names: {len(found_suspicious)} found")
            self.details['suspicious_exports'] = found_suspicious
    
    def _analyze_strings(self, dll_data: Dict[str, Any]):
        """Analyze extracted strings"""
        strings = dll_data.get('strings', [])
        
        # Check for suspicious strings
        suspicious_patterns = [
            'cmd.exe', 'powershell', 'wscript', 'cscript',
            'reg add', 'reg delete', 'net user', 'net localgroup',
            'schtasks', 'at ', 'sc create', 'sc start'
        ]
        
        found_suspicious = []
        for s in strings[:1000]:  # Check first 1000 strings
            string = s.get('string', '').lower()
            for pattern in suspicious_patterns:
                if pattern in string:
                    found_suspicious.append(s.get('string', '')[:100])
                    break
        
        if found_suspicious:
            self.risk_score += 10
            self.indicators.append(f"Suspicious strings found: {len(found_suspicious)}")
            self.details['suspicious_strings'] = found_suspicious[:20]  # Limit to 20
    
    def _analyze_resources(self, dll_data: Dict[str, Any]):
        """Analyze resources"""
        resources = dll_data.get('resources', {})
        
        # Check for embedded executables
        if resources.get('rcdata'):
            self.risk_score += 5
            self.indicators.append("Embedded data resources found")
    
    def _analyze_characteristics(self, dll_data: Dict[str, Any]):
        """Analyze PE characteristics"""
        headers = dll_data.get('headers', {})
        opt_header = headers.get('optional_header', {})
        
        # Check DLL characteristics
        dll_chars = opt_header.get('dll_characteristics_flags', [])
        
        # Missing security features
        if 'NX_COMPAT' not in dll_chars:
            self.risk_score += 5
            self.indicators.append("NX (DEP) not enabled")
        
        if 'DYNAMIC_BASE' not in dll_chars and 'HIGH_ENTROPY_VA' not in dll_chars:
            self.risk_score += 5
            self.indicators.append("ASLR not enabled")
    
    def _calculate_risk_level(self) -> str:
        """Calculate risk level based on score"""
        if self.risk_score >= 60:
            return 'HIGH'
        elif self.risk_score >= 30:
            return 'MEDIUM'
        elif self.risk_score >= 10:
            return 'LOW'
        else:
            return 'MINIMAL'
    
    def get_risk_summary(self, analysis: Dict[str, Any]) -> str:
        """Get human-readable risk summary"""
        risk_level = analysis['risk_level']
        score = analysis['risk_score']
        indicator_count = len(analysis['indicators'])
        
        summary = f"Risk Level: {risk_level} (Score: {score}/100)\n"
        summary += f"Indicators Found: {indicator_count}\n\n"
        
        if analysis['indicators']:
            summary += "Key Indicators:\n"
            for i, indicator in enumerate(analysis['indicators'][:10], 1):
                summary += f"  {i}. {indicator}\n"
        
        return summary

